# Generated from /Users/carlosconde/Desktop/marzo/antlr/marzo.g4 by ANTLR 4.9.3
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3!")
        buf.write("\u0092\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\3\2\3\2\3\2\3\3\3\3\3\3\3\3\7\3&\n\3\f")
        buf.write("\3\16\3)\13\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4")
        buf.write("\3\4\5\4\66\n\4\3\5\3\5\3\5\3\5\3\5\3\6\3\6\3\6\3\6\3")
        buf.write("\6\3\6\3\7\3\7\3\7\3\7\3\b\3\b\3\b\3\b\5\bK\n\b\3\t\3")
        buf.write("\t\3\t\3\t\3\t\3\t\3\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\13")
        buf.write("\3\13\3\13\3\13\3\13\3\13\3\13\3\f\3\f\3\f\3\f\3\f\3\f")
        buf.write("\3\f\3\r\3\r\3\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\7")
        buf.write("\16s\n\16\f\16\16\16v\13\16\3\16\3\16\3\17\3\17\3\17\3")
        buf.write("\17\3\17\3\17\3\17\3\17\7\17\u0082\n\17\f\17\16\17\u0085")
        buf.write("\13\17\3\17\3\17\3\17\3\17\7\17\u008b\n\17\f\17\16\17")
        buf.write("\u008e\13\17\3\17\3\17\3\17\2\2\20\2\4\6\b\n\f\16\20\22")
        buf.write("\24\26\30\32\34\2\3\3\2\17\24\2\u0090\2\36\3\2\2\2\4!")
        buf.write("\3\2\2\2\6\65\3\2\2\2\b\67\3\2\2\2\n<\3\2\2\2\fB\3\2\2")
        buf.write("\2\16J\3\2\2\2\20L\3\2\2\2\22S\3\2\2\2\24Z\3\2\2\2\26")
        buf.write("a\3\2\2\2\30h\3\2\2\2\32j\3\2\2\2\34y\3\2\2\2\36\37\7")
        buf.write(" \2\2\37 \7!\2\2 \3\3\2\2\2!\"\7\3\2\2\"#\7\35\2\2#\'")
        buf.write("\7\30\2\2$&\5\6\4\2%$\3\2\2\2&)\3\2\2\2\'%\3\2\2\2\'(")
        buf.write("\3\2\2\2(*\3\2\2\2)\'\3\2\2\2*+\7\31\2\2+\5\3\2\2\2,\66")
        buf.write("\5\b\5\2-\66\5\n\6\2.\66\5\f\7\2/\66\5\20\t\2\60\66\5")
        buf.write("\22\n\2\61\66\5\24\13\2\62\66\5\26\f\2\63\66\5\32\16\2")
        buf.write("\64\66\5\34\17\2\65,\3\2\2\2\65-\3\2\2\2\65.\3\2\2\2\65")
        buf.write("/\3\2\2\2\65\60\3\2\2\2\65\61\3\2\2\2\65\62\3\2\2\2\65")
        buf.write("\63\3\2\2\2\65\64\3\2\2\2\66\7\3\2\2\2\678\7\4\2\289\7")
        buf.write("\35\2\29:\7\34\2\2:;\b\5\1\2;\t\3\2\2\2<=\7\35\2\2=>\7")
        buf.write("\25\2\2>?\5\16\b\2?@\7\34\2\2@A\b\6\1\2A\13\3\2\2\2BC")
        buf.write("\7\5\2\2CD\5\16\b\2DE\7\34\2\2E\r\3\2\2\2FG\7\36\2\2G")
        buf.write("K\b\b\1\2HI\7\35\2\2IK\b\b\1\2JF\3\2\2\2JH\3\2\2\2K\17")
        buf.write("\3\2\2\2LM\7\35\2\2MN\7\25\2\2NO\7\36\2\2OP\7\b\2\2PQ")
        buf.write("\7\36\2\2QR\7\34\2\2R\21\3\2\2\2ST\7\35\2\2TU\7\25\2\2")
        buf.write("UV\7\36\2\2VW\7\t\2\2WX\7\36\2\2XY\7\34\2\2Y\23\3\2\2")
        buf.write("\2Z[\7\35\2\2[\\\7\25\2\2\\]\7\36\2\2]^\7\n\2\2^_\7\36")
        buf.write("\2\2_`\7\34\2\2`\25\3\2\2\2ab\7\35\2\2bc\7\25\2\2cd\7")
        buf.write("\36\2\2de\7\13\2\2ef\7\36\2\2fg\7\34\2\2g\27\3\2\2\2h")
        buf.write("i\t\2\2\2i\31\3\2\2\2jk\7\6\2\2kl\7\32\2\2lm\7\36\2\2")
        buf.write("mn\5\30\r\2no\7\36\2\2op\7\33\2\2pt\7\30\2\2qs\5\6\4\2")
        buf.write("rq\3\2\2\2sv\3\2\2\2tr\3\2\2\2tu\3\2\2\2uw\3\2\2\2vt\3")
        buf.write("\2\2\2wx\7\31\2\2x\33\3\2\2\2yz\7\6\2\2z{\7\32\2\2{|\7")
        buf.write("\36\2\2|}\5\30\r\2}~\7\36\2\2~\177\7\33\2\2\177\u0083")
        buf.write("\7\30\2\2\u0080\u0082\5\6\4\2\u0081\u0080\3\2\2\2\u0082")
        buf.write("\u0085\3\2\2\2\u0083\u0081\3\2\2\2\u0083\u0084\3\2\2\2")
        buf.write("\u0084\u0086\3\2\2\2\u0085\u0083\3\2\2\2\u0086\u0087\7")
        buf.write("\31\2\2\u0087\u0088\7\7\2\2\u0088\u008c\7\30\2\2\u0089")
        buf.write("\u008b\5\6\4\2\u008a\u0089\3\2\2\2\u008b\u008e\3\2\2\2")
        buf.write("\u008c\u008a\3\2\2\2\u008c\u008d\3\2\2\2\u008d\u008f\3")
        buf.write("\2\2\2\u008e\u008c\3\2\2\2\u008f\u0090\7\31\2\2\u0090")
        buf.write("\35\3\2\2\2\b\'\65Jt\u0083\u008c")
        return buf.getvalue()


class marzoParser ( Parser ):

    grammarFileName = "marzo.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'program'", "'var'", "'println'", "'if'", 
                     "'else'", "'+'", "'-'", "'*'", "'/'", "'&&'", "'||'", 
                     "'!'", "'>'", "'<'", "'>='", "'<='", "'=='", "'!='", 
                     "'='", "'true'", "'false'", "'{'", "'}'", "'('", "')'", 
                     "';'" ]

    symbolicNames = [ "<INVALID>", "PROGRAM", "VAR", "PRINTLN", "IF", "ELSE", 
                      "PLUS", "MINUS", "MULT", "DIV", "AND", "OR", "NOT", 
                      "GT", "LT", "GEQ", "LEQ", "EQ", "NEQ", "ASSIGN", "TRUE", 
                      "FALSE", "BRACKET_OPEN", "BRACKET_CLOSE", "PAR_OPEN", 
                      "PAR_CLOSE", "SEMICOLON", "ID", "NUMBER", "WS", "HELLO", 
                      "WORLD" ]

    RULE_start = 0
    RULE_program = 1
    RULE_sentence = 2
    RULE_var_decl = 3
    RULE_var_assign = 4
    RULE_println = 5
    RULE_expression = 6
    RULE_suma = 7
    RULE_resta = 8
    RULE_multiplicacion = 9
    RULE_division = 10
    RULE_comparison = 11
    RULE_ifsinelse = 12
    RULE_ifconelse = 13

    ruleNames =  [ "start", "program", "sentence", "var_decl", "var_assign", 
                   "println", "expression", "suma", "resta", "multiplicacion", 
                   "division", "comparison", "ifsinelse", "ifconelse" ]

    EOF = Token.EOF
    PROGRAM=1
    VAR=2
    PRINTLN=3
    IF=4
    ELSE=5
    PLUS=6
    MINUS=7
    MULT=8
    DIV=9
    AND=10
    OR=11
    NOT=12
    GT=13
    LT=14
    GEQ=15
    LEQ=16
    EQ=17
    NEQ=18
    ASSIGN=19
    TRUE=20
    FALSE=21
    BRACKET_OPEN=22
    BRACKET_CLOSE=23
    PAR_OPEN=24
    PAR_CLOSE=25
    SEMICOLON=26
    ID=27
    NUMBER=28
    WS=29
    HELLO=30
    WORLD=31

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None


    symbolTable = {};


    class StartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HELLO(self):
            return self.getToken(marzoParser.HELLO, 0)

        def WORLD(self):
            return self.getToken(marzoParser.WORLD, 0)

        def getRuleIndex(self):
            return marzoParser.RULE_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart" ):
                listener.enterStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart" ):
                listener.exitStart(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStart" ):
                return visitor.visitStart(self)
            else:
                return visitor.visitChildren(self)




    def start(self):

        localctx = marzoParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 28
            self.match(marzoParser.HELLO)
            self.state = 29
            self.match(marzoParser.WORLD)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PROGRAM(self):
            return self.getToken(marzoParser.PROGRAM, 0)

        def ID(self):
            return self.getToken(marzoParser.ID, 0)

        def BRACKET_OPEN(self):
            return self.getToken(marzoParser.BRACKET_OPEN, 0)

        def BRACKET_CLOSE(self):
            return self.getToken(marzoParser.BRACKET_CLOSE, 0)

        def sentence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(marzoParser.SentenceContext)
            else:
                return self.getTypedRuleContext(marzoParser.SentenceContext,i)


        def getRuleIndex(self):
            return marzoParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = marzoParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 31
            self.match(marzoParser.PROGRAM)
            self.state = 32
            self.match(marzoParser.ID)
            self.state = 33
            self.match(marzoParser.BRACKET_OPEN)
            self.state = 37
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << marzoParser.VAR) | (1 << marzoParser.PRINTLN) | (1 << marzoParser.IF) | (1 << marzoParser.ID))) != 0):
                self.state = 34
                self.sentence()
                self.state = 39
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 40
            self.match(marzoParser.BRACKET_CLOSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SentenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var_decl(self):
            return self.getTypedRuleContext(marzoParser.Var_declContext,0)


        def var_assign(self):
            return self.getTypedRuleContext(marzoParser.Var_assignContext,0)


        def println(self):
            return self.getTypedRuleContext(marzoParser.PrintlnContext,0)


        def suma(self):
            return self.getTypedRuleContext(marzoParser.SumaContext,0)


        def resta(self):
            return self.getTypedRuleContext(marzoParser.RestaContext,0)


        def multiplicacion(self):
            return self.getTypedRuleContext(marzoParser.MultiplicacionContext,0)


        def division(self):
            return self.getTypedRuleContext(marzoParser.DivisionContext,0)


        def ifsinelse(self):
            return self.getTypedRuleContext(marzoParser.IfsinelseContext,0)


        def ifconelse(self):
            return self.getTypedRuleContext(marzoParser.IfconelseContext,0)


        def getRuleIndex(self):
            return marzoParser.RULE_sentence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSentence" ):
                listener.enterSentence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSentence" ):
                listener.exitSentence(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSentence" ):
                return visitor.visitSentence(self)
            else:
                return visitor.visitChildren(self)




    def sentence(self):

        localctx = marzoParser.SentenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_sentence)
        try:
            self.state = 51
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 42
                self.var_decl()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 43
                self.var_assign()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 44
                self.println()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 45
                self.suma()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 46
                self.resta()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 47
                self.multiplicacion()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 48
                self.division()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 49
                self.ifsinelse()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 50
                self.ifconelse()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Var_declContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._ID = None # Token

        def VAR(self):
            return self.getToken(marzoParser.VAR, 0)

        def ID(self):
            return self.getToken(marzoParser.ID, 0)

        def SEMICOLON(self):
            return self.getToken(marzoParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return marzoParser.RULE_var_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_decl" ):
                listener.enterVar_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_decl" ):
                listener.exitVar_decl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar_decl" ):
                return visitor.visitVar_decl(self)
            else:
                return visitor.visitChildren(self)




    def var_decl(self):

        localctx = marzoParser.Var_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_var_decl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 53
            self.match(marzoParser.VAR)
            self.state = 54
            localctx._ID = self.match(marzoParser.ID)
            self.state = 55
            self.match(marzoParser.SEMICOLON)
            self.symbolTable[(None if localctx._ID is None else localctx._ID.text)] = 0;
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Var_assignContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._ID = None # Token
            self._expression = None # ExpressionContext

        def ID(self):
            return self.getToken(marzoParser.ID, 0)

        def ASSIGN(self):
            return self.getToken(marzoParser.ASSIGN, 0)

        def expression(self):
            return self.getTypedRuleContext(marzoParser.ExpressionContext,0)


        def SEMICOLON(self):
            return self.getToken(marzoParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return marzoParser.RULE_var_assign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_assign" ):
                listener.enterVar_assign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_assign" ):
                listener.exitVar_assign(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVar_assign" ):
                return visitor.visitVar_assign(self)
            else:
                return visitor.visitChildren(self)




    def var_assign(self):

        localctx = marzoParser.Var_assignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_var_assign)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 58
            localctx._ID = self.match(marzoParser.ID)
            self.state = 59
            self.match(marzoParser.ASSIGN)
            self.state = 60
            localctx._expression = self.expression()
            self.state = 61
            self.match(marzoParser.SEMICOLON)
            self.symbolTable[(None if localctx._ID is None else localctx._ID.text)] = localctx._expression.value;
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrintlnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRINTLN(self):
            return self.getToken(marzoParser.PRINTLN, 0)

        def expression(self):
            return self.getTypedRuleContext(marzoParser.ExpressionContext,0)


        def SEMICOLON(self):
            return self.getToken(marzoParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return marzoParser.RULE_println

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrintln" ):
                listener.enterPrintln(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrintln" ):
                listener.exitPrintln(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrintln" ):
                return visitor.visitPrintln(self)
            else:
                return visitor.visitChildren(self)




    def println(self):

        localctx = marzoParser.PrintlnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_println)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 64
            self.match(marzoParser.PRINTLN)
            self.state = 65
            self.expression()
            self.state = 66
            self.match(marzoParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value = None
            self._NUMBER = None # Token
            self._ID = None # Token

        def NUMBER(self):
            return self.getToken(marzoParser.NUMBER, 0)

        def ID(self):
            return self.getToken(marzoParser.ID, 0)

        def getRuleIndex(self):
            return marzoParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = marzoParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_expression)
        try:
            self.state = 72
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [marzoParser.NUMBER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 68
                localctx._NUMBER = self.match(marzoParser.NUMBER)
                localctx.value =  int((None if localctx._NUMBER is None else localctx._NUMBER.text))
                pass
            elif token in [marzoParser.ID]:
                self.enterOuterAlt(localctx, 2)
                self.state = 70
                localctx._ID = self.match(marzoParser.ID)
                localctx.value =  self.symbolTable.get((None if localctx._ID is None else localctx._ID.text))
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SumaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(marzoParser.ID, 0)

        def ASSIGN(self):
            return self.getToken(marzoParser.ASSIGN, 0)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(marzoParser.NUMBER)
            else:
                return self.getToken(marzoParser.NUMBER, i)

        def PLUS(self):
            return self.getToken(marzoParser.PLUS, 0)

        def SEMICOLON(self):
            return self.getToken(marzoParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return marzoParser.RULE_suma

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSuma" ):
                listener.enterSuma(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSuma" ):
                listener.exitSuma(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSuma" ):
                return visitor.visitSuma(self)
            else:
                return visitor.visitChildren(self)




    def suma(self):

        localctx = marzoParser.SumaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_suma)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 74
            self.match(marzoParser.ID)
            self.state = 75
            self.match(marzoParser.ASSIGN)
            self.state = 76
            self.match(marzoParser.NUMBER)
            self.state = 77
            self.match(marzoParser.PLUS)
            self.state = 78
            self.match(marzoParser.NUMBER)
            self.state = 79
            self.match(marzoParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RestaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(marzoParser.ID, 0)

        def ASSIGN(self):
            return self.getToken(marzoParser.ASSIGN, 0)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(marzoParser.NUMBER)
            else:
                return self.getToken(marzoParser.NUMBER, i)

        def MINUS(self):
            return self.getToken(marzoParser.MINUS, 0)

        def SEMICOLON(self):
            return self.getToken(marzoParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return marzoParser.RULE_resta

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResta" ):
                listener.enterResta(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResta" ):
                listener.exitResta(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResta" ):
                return visitor.visitResta(self)
            else:
                return visitor.visitChildren(self)




    def resta(self):

        localctx = marzoParser.RestaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_resta)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 81
            self.match(marzoParser.ID)
            self.state = 82
            self.match(marzoParser.ASSIGN)
            self.state = 83
            self.match(marzoParser.NUMBER)
            self.state = 84
            self.match(marzoParser.MINUS)
            self.state = 85
            self.match(marzoParser.NUMBER)
            self.state = 86
            self.match(marzoParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplicacionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(marzoParser.ID, 0)

        def ASSIGN(self):
            return self.getToken(marzoParser.ASSIGN, 0)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(marzoParser.NUMBER)
            else:
                return self.getToken(marzoParser.NUMBER, i)

        def MULT(self):
            return self.getToken(marzoParser.MULT, 0)

        def SEMICOLON(self):
            return self.getToken(marzoParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return marzoParser.RULE_multiplicacion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultiplicacion" ):
                listener.enterMultiplicacion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultiplicacion" ):
                listener.exitMultiplicacion(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplicacion" ):
                return visitor.visitMultiplicacion(self)
            else:
                return visitor.visitChildren(self)




    def multiplicacion(self):

        localctx = marzoParser.MultiplicacionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_multiplicacion)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 88
            self.match(marzoParser.ID)
            self.state = 89
            self.match(marzoParser.ASSIGN)
            self.state = 90
            self.match(marzoParser.NUMBER)
            self.state = 91
            self.match(marzoParser.MULT)
            self.state = 92
            self.match(marzoParser.NUMBER)
            self.state = 93
            self.match(marzoParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DivisionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(marzoParser.ID, 0)

        def ASSIGN(self):
            return self.getToken(marzoParser.ASSIGN, 0)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(marzoParser.NUMBER)
            else:
                return self.getToken(marzoParser.NUMBER, i)

        def DIV(self):
            return self.getToken(marzoParser.DIV, 0)

        def SEMICOLON(self):
            return self.getToken(marzoParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return marzoParser.RULE_division

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDivision" ):
                listener.enterDivision(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDivision" ):
                listener.exitDivision(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDivision" ):
                return visitor.visitDivision(self)
            else:
                return visitor.visitChildren(self)




    def division(self):

        localctx = marzoParser.DivisionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_division)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 95
            self.match(marzoParser.ID)
            self.state = 96
            self.match(marzoParser.ASSIGN)
            self.state = 97
            self.match(marzoParser.NUMBER)
            self.state = 98
            self.match(marzoParser.DIV)
            self.state = 99
            self.match(marzoParser.NUMBER)
            self.state = 100
            self.match(marzoParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GT(self):
            return self.getToken(marzoParser.GT, 0)

        def LT(self):
            return self.getToken(marzoParser.LT, 0)

        def GEQ(self):
            return self.getToken(marzoParser.GEQ, 0)

        def LEQ(self):
            return self.getToken(marzoParser.LEQ, 0)

        def EQ(self):
            return self.getToken(marzoParser.EQ, 0)

        def NEQ(self):
            return self.getToken(marzoParser.NEQ, 0)

        def getRuleIndex(self):
            return marzoParser.RULE_comparison

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison" ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison" ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison" ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)




    def comparison(self):

        localctx = marzoParser.ComparisonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_comparison)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << marzoParser.GT) | (1 << marzoParser.LT) | (1 << marzoParser.GEQ) | (1 << marzoParser.LEQ) | (1 << marzoParser.EQ) | (1 << marzoParser.NEQ))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfsinelseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(marzoParser.IF, 0)

        def PAR_OPEN(self):
            return self.getToken(marzoParser.PAR_OPEN, 0)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(marzoParser.NUMBER)
            else:
                return self.getToken(marzoParser.NUMBER, i)

        def comparison(self):
            return self.getTypedRuleContext(marzoParser.ComparisonContext,0)


        def PAR_CLOSE(self):
            return self.getToken(marzoParser.PAR_CLOSE, 0)

        def BRACKET_OPEN(self):
            return self.getToken(marzoParser.BRACKET_OPEN, 0)

        def BRACKET_CLOSE(self):
            return self.getToken(marzoParser.BRACKET_CLOSE, 0)

        def sentence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(marzoParser.SentenceContext)
            else:
                return self.getTypedRuleContext(marzoParser.SentenceContext,i)


        def getRuleIndex(self):
            return marzoParser.RULE_ifsinelse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfsinelse" ):
                listener.enterIfsinelse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfsinelse" ):
                listener.exitIfsinelse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfsinelse" ):
                return visitor.visitIfsinelse(self)
            else:
                return visitor.visitChildren(self)




    def ifsinelse(self):

        localctx = marzoParser.IfsinelseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_ifsinelse)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104
            self.match(marzoParser.IF)
            self.state = 105
            self.match(marzoParser.PAR_OPEN)
            self.state = 106
            self.match(marzoParser.NUMBER)
            self.state = 107
            self.comparison()
            self.state = 108
            self.match(marzoParser.NUMBER)
            self.state = 109
            self.match(marzoParser.PAR_CLOSE)
            self.state = 110
            self.match(marzoParser.BRACKET_OPEN)
            self.state = 114
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << marzoParser.VAR) | (1 << marzoParser.PRINTLN) | (1 << marzoParser.IF) | (1 << marzoParser.ID))) != 0):
                self.state = 111
                self.sentence()
                self.state = 116
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 117
            self.match(marzoParser.BRACKET_CLOSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfconelseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(marzoParser.IF, 0)

        def PAR_OPEN(self):
            return self.getToken(marzoParser.PAR_OPEN, 0)

        def NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(marzoParser.NUMBER)
            else:
                return self.getToken(marzoParser.NUMBER, i)

        def comparison(self):
            return self.getTypedRuleContext(marzoParser.ComparisonContext,0)


        def PAR_CLOSE(self):
            return self.getToken(marzoParser.PAR_CLOSE, 0)

        def BRACKET_OPEN(self, i:int=None):
            if i is None:
                return self.getTokens(marzoParser.BRACKET_OPEN)
            else:
                return self.getToken(marzoParser.BRACKET_OPEN, i)

        def BRACKET_CLOSE(self, i:int=None):
            if i is None:
                return self.getTokens(marzoParser.BRACKET_CLOSE)
            else:
                return self.getToken(marzoParser.BRACKET_CLOSE, i)

        def ELSE(self):
            return self.getToken(marzoParser.ELSE, 0)

        def sentence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(marzoParser.SentenceContext)
            else:
                return self.getTypedRuleContext(marzoParser.SentenceContext,i)


        def getRuleIndex(self):
            return marzoParser.RULE_ifconelse

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfconelse" ):
                listener.enterIfconelse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfconelse" ):
                listener.exitIfconelse(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfconelse" ):
                return visitor.visitIfconelse(self)
            else:
                return visitor.visitChildren(self)




    def ifconelse(self):

        localctx = marzoParser.IfconelseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_ifconelse)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            self.match(marzoParser.IF)
            self.state = 120
            self.match(marzoParser.PAR_OPEN)
            self.state = 121
            self.match(marzoParser.NUMBER)
            self.state = 122
            self.comparison()
            self.state = 123
            self.match(marzoParser.NUMBER)
            self.state = 124
            self.match(marzoParser.PAR_CLOSE)
            self.state = 125
            self.match(marzoParser.BRACKET_OPEN)
            self.state = 129
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << marzoParser.VAR) | (1 << marzoParser.PRINTLN) | (1 << marzoParser.IF) | (1 << marzoParser.ID))) != 0):
                self.state = 126
                self.sentence()
                self.state = 131
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 132
            self.match(marzoParser.BRACKET_CLOSE)
            self.state = 133
            self.match(marzoParser.ELSE)
            self.state = 134
            self.match(marzoParser.BRACKET_OPEN)
            self.state = 138
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << marzoParser.VAR) | (1 << marzoParser.PRINTLN) | (1 << marzoParser.IF) | (1 << marzoParser.ID))) != 0):
                self.state = 135
                self.sentence()
                self.state = 140
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 141
            self.match(marzoParser.BRACKET_CLOSE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





